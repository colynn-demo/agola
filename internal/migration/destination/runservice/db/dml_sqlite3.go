// Code generated by go generate; DO NOT EDIT.
package db

import (
	"encoding/json"
	stdsql "database/sql"
	"time"

	"github.com/sorintlab/errors"
	sq "github.com/huandu/go-sqlbuilder"

	"agola.io/agola/internal/sqlg/sql"

	types "agola.io/agola/services/runservice/types"
)
var (
	changeGroupInsertSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inValue string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("changegroup").Cols("id", "revision", "creation_time", "update_time", "name", "value").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inValue)
	}
	changeGroupUpdateSqlite3 = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inValue string) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("changegroup").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("value", inValue)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	changeGroupInsertRawSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inValue string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("changegroup").Cols("id", "revision", "creation_time", "update_time", "name", "value").SQL("").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inValue)
	}
)

func (d *DB) insertChangeGroupSqlite3(tx *sql.Tx, changegroup *types.ChangeGroup) error {
	q := changeGroupInsertSqlite3(changegroup.ID, changegroup.Revision, changegroup.CreationTime, changegroup.UpdateTime, changegroup.Name, changegroup.Value)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert changeGroup")
	}

	return nil
}

func (d *DB) updateChangeGroupSqlite3(tx *sql.Tx, curRevision uint64, changegroup *types.ChangeGroup) (stdsql.Result, error) {
	q := changeGroupUpdateSqlite3(curRevision, changegroup.ID, changegroup.Revision, changegroup.CreationTime, changegroup.UpdateTime, changegroup.Name, changegroup.Value)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update changeGroup")
	}

	return res, nil
}

func (d *DB) insertRawChangeGroupSqlite3(tx *sql.Tx, changegroup *types.ChangeGroup) error {
	q := changeGroupInsertRawSqlite3(changegroup.ID, changegroup.Revision, changegroup.CreationTime, changegroup.UpdateTime, changegroup.Name, changegroup.Value)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert changeGroup")
	}

	return nil
}
var (
	runConfigInsertSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inGroup string, inSetupErrors []byte, inAnnotations []byte, inStaticEnvironment []byte, inEnvironment []byte, inTasks []byte, inCacheGroup string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("runconfig").Cols("id", "revision", "creation_time", "update_time", "name", "run_group", "setup_errors", "annotations", "static_environment", "environment", "tasks", "cache_group").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inGroup, inSetupErrors, inAnnotations, inStaticEnvironment, inEnvironment, inTasks, inCacheGroup)
	}
	runConfigUpdateSqlite3 = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inGroup string, inSetupErrors []byte, inAnnotations []byte, inStaticEnvironment []byte, inEnvironment []byte, inTasks []byte, inCacheGroup string) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("runconfig").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("run_group", inGroup), ub.Assign("setup_errors", inSetupErrors), ub.Assign("annotations", inAnnotations), ub.Assign("static_environment", inStaticEnvironment), ub.Assign("environment", inEnvironment), ub.Assign("tasks", inTasks), ub.Assign("cache_group", inCacheGroup)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	runConfigInsertRawSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inGroup string, inSetupErrors []byte, inAnnotations []byte, inStaticEnvironment []byte, inEnvironment []byte, inTasks []byte, inCacheGroup string) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("runconfig").Cols("id", "revision", "creation_time", "update_time", "name", "run_group", "setup_errors", "annotations", "static_environment", "environment", "tasks", "cache_group").SQL("").Values(inId, inRevision, inCreationTime, inUpdateTime, inName, inGroup, inSetupErrors, inAnnotations, inStaticEnvironment, inEnvironment, inTasks, inCacheGroup)
	}
)

func (d *DB) insertRunConfigSqlite3(tx *sql.Tx, runconfig *types.RunConfig) error {
	inSetupErrorsJSON, err := json.Marshal(runconfig.SetupErrors)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.SetupErrors")
	}
	inAnnotationsJSON, err := json.Marshal(runconfig.Annotations)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.Annotations")
	}
	inStaticEnvironmentJSON, err := json.Marshal(runconfig.StaticEnvironment)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.StaticEnvironment")
	}
	inEnvironmentJSON, err := json.Marshal(runconfig.Environment)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.Environment")
	}
	inTasksJSON, err := json.Marshal(runconfig.Tasks)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.Tasks")
	}
	q := runConfigInsertSqlite3(runconfig.ID, runconfig.Revision, runconfig.CreationTime, runconfig.UpdateTime, runconfig.Name, runconfig.Group, inSetupErrorsJSON, inAnnotationsJSON, inStaticEnvironmentJSON, inEnvironmentJSON, inTasksJSON, runconfig.CacheGroup)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert runConfig")
	}

	return nil
}

func (d *DB) updateRunConfigSqlite3(tx *sql.Tx, curRevision uint64, runconfig *types.RunConfig) (stdsql.Result, error) {
	inSetupErrorsJSON, err := json.Marshal(runconfig.SetupErrors)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal runconfig.SetupErrors")
	}
	inAnnotationsJSON, err := json.Marshal(runconfig.Annotations)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal runconfig.Annotations")
	}
	inStaticEnvironmentJSON, err := json.Marshal(runconfig.StaticEnvironment)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal runconfig.StaticEnvironment")
	}
	inEnvironmentJSON, err := json.Marshal(runconfig.Environment)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal runconfig.Environment")
	}
	inTasksJSON, err := json.Marshal(runconfig.Tasks)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal runconfig.Tasks")
	}
	q := runConfigUpdateSqlite3(curRevision, runconfig.ID, runconfig.Revision, runconfig.CreationTime, runconfig.UpdateTime, runconfig.Name, runconfig.Group, inSetupErrorsJSON, inAnnotationsJSON, inStaticEnvironmentJSON, inEnvironmentJSON, inTasksJSON, runconfig.CacheGroup)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update runConfig")
	}

	return res, nil
}

func (d *DB) insertRawRunConfigSqlite3(tx *sql.Tx, runconfig *types.RunConfig) error {
	inSetupErrorsJSON, err := json.Marshal(runconfig.SetupErrors)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.SetupErrors")
	}
	inAnnotationsJSON, err := json.Marshal(runconfig.Annotations)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.Annotations")
	}
	inStaticEnvironmentJSON, err := json.Marshal(runconfig.StaticEnvironment)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.StaticEnvironment")
	}
	inEnvironmentJSON, err := json.Marshal(runconfig.Environment)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.Environment")
	}
	inTasksJSON, err := json.Marshal(runconfig.Tasks)
	if err != nil {
		return errors.Wrap(err, "failed to marshal runconfig.Tasks")
	}
	q := runConfigInsertRawSqlite3(runconfig.ID, runconfig.Revision, runconfig.CreationTime, runconfig.UpdateTime, runconfig.Name, runconfig.Group, inSetupErrorsJSON, inAnnotationsJSON, inStaticEnvironmentJSON, inEnvironmentJSON, inTasksJSON, runconfig.CacheGroup)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert runConfig")
	}

	return nil
}
var (
	runInsertSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inSequence uint64, inName string, inRunConfigID string, inCounter uint64, inGroup string, inAnnotations []byte, inPhase types.RunPhase, inResult types.RunResult, inStop bool, inTasks []byte, inEnqueueTime *time.Time, inStartTime *time.Time, inEndTime *time.Time, inArchived bool) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("run").Cols("id", "revision", "creation_time", "update_time", "sequence", "name", "run_config_id", "counter", "run_group", "annotations", "phase", "result", "stop", "tasks", "enqueue_time", "start_time", "end_time", "archived").Values(inId, inRevision, inCreationTime, inUpdateTime, inSequence, inName, inRunConfigID, inCounter, inGroup, inAnnotations, inPhase, inResult, inStop, inTasks, inEnqueueTime, inStartTime, inEndTime, inArchived)
	}
	runUpdateSqlite3 = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inName string, inRunConfigID string, inCounter uint64, inGroup string, inAnnotations []byte, inPhase types.RunPhase, inResult types.RunResult, inStop bool, inTasks []byte, inEnqueueTime *time.Time, inStartTime *time.Time, inEndTime *time.Time, inArchived bool) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("run").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("name", inName), ub.Assign("run_config_id", inRunConfigID), ub.Assign("counter", inCounter), ub.Assign("run_group", inGroup), ub.Assign("annotations", inAnnotations), ub.Assign("phase", inPhase), ub.Assign("result", inResult), ub.Assign("stop", inStop), ub.Assign("tasks", inTasks), ub.Assign("enqueue_time", inEnqueueTime), ub.Assign("start_time", inStartTime), ub.Assign("end_time", inEndTime), ub.Assign("archived", inArchived)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	runInsertRawSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inSequence uint64, inName string, inRunConfigID string, inCounter uint64, inGroup string, inAnnotations []byte, inPhase types.RunPhase, inResult types.RunResult, inStop bool, inTasks []byte, inEnqueueTime *time.Time, inStartTime *time.Time, inEndTime *time.Time, inArchived bool) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("run").Cols("id", "revision", "creation_time", "update_time", "sequence", "name", "run_config_id", "counter", "run_group", "annotations", "phase", "result", "stop", "tasks", "enqueue_time", "start_time", "end_time", "archived").SQL("").Values(inId, inRevision, inCreationTime, inUpdateTime, inSequence, inName, inRunConfigID, inCounter, inGroup, inAnnotations, inPhase, inResult, inStop, inTasks, inEnqueueTime, inStartTime, inEndTime, inArchived)
	}
)

func (d *DB) insertRunSqlite3(tx *sql.Tx, run *types.Run) error {
	inAnnotationsJSON, err := json.Marshal(run.Annotations)
	if err != nil {
		return errors.Wrap(err, "failed to marshal run.Annotations")
	}
	inTasksJSON, err := json.Marshal(run.Tasks)
	if err != nil {
		return errors.Wrap(err, "failed to marshal run.Tasks")
	}
	q := runInsertSqlite3(run.ID, run.Revision, run.CreationTime, run.UpdateTime, run.Sequence, run.Name, run.RunConfigID, run.Counter, run.Group, inAnnotationsJSON, run.Phase, run.Result, run.Stop, inTasksJSON, run.EnqueueTime, run.StartTime, run.EndTime, run.Archived)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert run")
	}

	return nil
}

func (d *DB) updateRunSqlite3(tx *sql.Tx, curRevision uint64, run *types.Run) (stdsql.Result, error) {
	inAnnotationsJSON, err := json.Marshal(run.Annotations)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal run.Annotations")
	}
	inTasksJSON, err := json.Marshal(run.Tasks)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal run.Tasks")
	}
	q := runUpdateSqlite3(curRevision, run.ID, run.Revision, run.CreationTime, run.UpdateTime, run.Name, run.RunConfigID, run.Counter, run.Group, inAnnotationsJSON, run.Phase, run.Result, run.Stop, inTasksJSON, run.EnqueueTime, run.StartTime, run.EndTime, run.Archived)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update run")
	}

	return res, nil
}

func (d *DB) insertRawRunSqlite3(tx *sql.Tx, run *types.Run) error {
	inAnnotationsJSON, err := json.Marshal(run.Annotations)
	if err != nil {
		return errors.Wrap(err, "failed to marshal run.Annotations")
	}
	inTasksJSON, err := json.Marshal(run.Tasks)
	if err != nil {
		return errors.Wrap(err, "failed to marshal run.Tasks")
	}
	q := runInsertRawSqlite3(run.ID, run.Revision, run.CreationTime, run.UpdateTime, run.Sequence, run.Name, run.RunConfigID, run.Counter, run.Group, inAnnotationsJSON, run.Phase, run.Result, run.Stop, inTasksJSON, run.EnqueueTime, run.StartTime, run.EndTime, run.Archived)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert run")
	}

	return nil
}
var (
	runCounterInsertSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inGroupID string, inValue uint64) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("runcounter").Cols("id", "revision", "creation_time", "update_time", "group_id", "value").Values(inId, inRevision, inCreationTime, inUpdateTime, inGroupID, inValue)
	}
	runCounterUpdateSqlite3 = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inGroupID string, inValue uint64) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("runcounter").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("group_id", inGroupID), ub.Assign("value", inValue)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	runCounterInsertRawSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inGroupID string, inValue uint64) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("runcounter").Cols("id", "revision", "creation_time", "update_time", "group_id", "value").SQL("").Values(inId, inRevision, inCreationTime, inUpdateTime, inGroupID, inValue)
	}
)

func (d *DB) insertRunCounterSqlite3(tx *sql.Tx, runcounter *types.RunCounter) error {
	q := runCounterInsertSqlite3(runcounter.ID, runcounter.Revision, runcounter.CreationTime, runcounter.UpdateTime, runcounter.GroupID, runcounter.Value)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert runCounter")
	}

	return nil
}

func (d *DB) updateRunCounterSqlite3(tx *sql.Tx, curRevision uint64, runcounter *types.RunCounter) (stdsql.Result, error) {
	q := runCounterUpdateSqlite3(curRevision, runcounter.ID, runcounter.Revision, runcounter.CreationTime, runcounter.UpdateTime, runcounter.GroupID, runcounter.Value)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update runCounter")
	}

	return res, nil
}

func (d *DB) insertRawRunCounterSqlite3(tx *sql.Tx, runcounter *types.RunCounter) error {
	q := runCounterInsertRawSqlite3(runcounter.ID, runcounter.Revision, runcounter.CreationTime, runcounter.UpdateTime, runcounter.GroupID, runcounter.Value)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert runCounter")
	}

	return nil
}
var (
	runEventInsertSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inSequence uint64, inRunID string, inPhase types.RunPhase, inResult types.RunResult) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("runevent").Cols("id", "revision", "creation_time", "update_time", "sequence", "run_id", "phase", "result").Values(inId, inRevision, inCreationTime, inUpdateTime, inSequence, inRunID, inPhase, inResult)
	}
	runEventUpdateSqlite3 = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inRunID string, inPhase types.RunPhase, inResult types.RunResult) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("runevent").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("run_id", inRunID), ub.Assign("phase", inPhase), ub.Assign("result", inResult)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	runEventInsertRawSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inSequence uint64, inRunID string, inPhase types.RunPhase, inResult types.RunResult) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("runevent").Cols("id", "revision", "creation_time", "update_time", "sequence", "run_id", "phase", "result").SQL("").Values(inId, inRevision, inCreationTime, inUpdateTime, inSequence, inRunID, inPhase, inResult)
	}
)

func (d *DB) insertRunEventSqlite3(tx *sql.Tx, runevent *types.RunEvent) error {
	q := runEventInsertSqlite3(runevent.ID, runevent.Revision, runevent.CreationTime, runevent.UpdateTime, runevent.Sequence, runevent.RunID, runevent.Phase, runevent.Result)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert runEvent")
	}

	return nil
}

func (d *DB) updateRunEventSqlite3(tx *sql.Tx, curRevision uint64, runevent *types.RunEvent) (stdsql.Result, error) {
	q := runEventUpdateSqlite3(curRevision, runevent.ID, runevent.Revision, runevent.CreationTime, runevent.UpdateTime, runevent.RunID, runevent.Phase, runevent.Result)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update runEvent")
	}

	return res, nil
}

func (d *DB) insertRawRunEventSqlite3(tx *sql.Tx, runevent *types.RunEvent) error {
	q := runEventInsertRawSqlite3(runevent.ID, runevent.Revision, runevent.CreationTime, runevent.UpdateTime, runevent.Sequence, runevent.RunID, runevent.Phase, runevent.Result)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert runEvent")
	}

	return nil
}
var (
	executorInsertSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inExecutorID string, inListenURL string, inArchs []byte, inLabels []byte, inAllowPrivilegedContainers bool, inActiveTasksLimit int, inActiveTasks int, inDynamic bool, inExecutorGroup string, inSiblingsExecutors []byte) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("executor").Cols("id", "revision", "creation_time", "update_time", "executor_id", "listen_url", "archs", "labels", "allow_privileged_containers", "active_tasks_limit", "active_tasks", "dynamic", "executor_group", "siblings_executors").Values(inId, inRevision, inCreationTime, inUpdateTime, inExecutorID, inListenURL, inArchs, inLabels, inAllowPrivilegedContainers, inActiveTasksLimit, inActiveTasks, inDynamic, inExecutorGroup, inSiblingsExecutors)
	}
	executorUpdateSqlite3 = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inExecutorID string, inListenURL string, inArchs []byte, inLabels []byte, inAllowPrivilegedContainers bool, inActiveTasksLimit int, inActiveTasks int, inDynamic bool, inExecutorGroup string, inSiblingsExecutors []byte) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("executor").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("executor_id", inExecutorID), ub.Assign("listen_url", inListenURL), ub.Assign("archs", inArchs), ub.Assign("labels", inLabels), ub.Assign("allow_privileged_containers", inAllowPrivilegedContainers), ub.Assign("active_tasks_limit", inActiveTasksLimit), ub.Assign("active_tasks", inActiveTasks), ub.Assign("dynamic", inDynamic), ub.Assign("executor_group", inExecutorGroup), ub.Assign("siblings_executors", inSiblingsExecutors)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	executorInsertRawSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inExecutorID string, inListenURL string, inArchs []byte, inLabels []byte, inAllowPrivilegedContainers bool, inActiveTasksLimit int, inActiveTasks int, inDynamic bool, inExecutorGroup string, inSiblingsExecutors []byte) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("executor").Cols("id", "revision", "creation_time", "update_time", "executor_id", "listen_url", "archs", "labels", "allow_privileged_containers", "active_tasks_limit", "active_tasks", "dynamic", "executor_group", "siblings_executors").SQL("").Values(inId, inRevision, inCreationTime, inUpdateTime, inExecutorID, inListenURL, inArchs, inLabels, inAllowPrivilegedContainers, inActiveTasksLimit, inActiveTasks, inDynamic, inExecutorGroup, inSiblingsExecutors)
	}
)

func (d *DB) insertExecutorSqlite3(tx *sql.Tx, executor *types.Executor) error {
	inArchsJSON, err := json.Marshal(executor.Archs)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executor.Archs")
	}
	inLabelsJSON, err := json.Marshal(executor.Labels)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executor.Labels")
	}
	inSiblingsExecutorsJSON, err := json.Marshal(executor.SiblingsExecutors)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executor.SiblingsExecutors")
	}
	q := executorInsertSqlite3(executor.ID, executor.Revision, executor.CreationTime, executor.UpdateTime, executor.ExecutorID, executor.ListenURL, inArchsJSON, inLabelsJSON, executor.AllowPrivilegedContainers, executor.ActiveTasksLimit, executor.ActiveTasks, executor.Dynamic, executor.ExecutorGroup, inSiblingsExecutorsJSON)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert executor")
	}

	return nil
}

func (d *DB) updateExecutorSqlite3(tx *sql.Tx, curRevision uint64, executor *types.Executor) (stdsql.Result, error) {
	inArchsJSON, err := json.Marshal(executor.Archs)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal executor.Archs")
	}
	inLabelsJSON, err := json.Marshal(executor.Labels)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal executor.Labels")
	}
	inSiblingsExecutorsJSON, err := json.Marshal(executor.SiblingsExecutors)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal executor.SiblingsExecutors")
	}
	q := executorUpdateSqlite3(curRevision, executor.ID, executor.Revision, executor.CreationTime, executor.UpdateTime, executor.ExecutorID, executor.ListenURL, inArchsJSON, inLabelsJSON, executor.AllowPrivilegedContainers, executor.ActiveTasksLimit, executor.ActiveTasks, executor.Dynamic, executor.ExecutorGroup, inSiblingsExecutorsJSON)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update executor")
	}

	return res, nil
}

func (d *DB) insertRawExecutorSqlite3(tx *sql.Tx, executor *types.Executor) error {
	inArchsJSON, err := json.Marshal(executor.Archs)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executor.Archs")
	}
	inLabelsJSON, err := json.Marshal(executor.Labels)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executor.Labels")
	}
	inSiblingsExecutorsJSON, err := json.Marshal(executor.SiblingsExecutors)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executor.SiblingsExecutors")
	}
	q := executorInsertRawSqlite3(executor.ID, executor.Revision, executor.CreationTime, executor.UpdateTime, executor.ExecutorID, executor.ListenURL, inArchsJSON, inLabelsJSON, executor.AllowPrivilegedContainers, executor.ActiveTasksLimit, executor.ActiveTasks, executor.Dynamic, executor.ExecutorGroup, inSiblingsExecutorsJSON)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert executor")
	}

	return nil
}
var (
	executorTaskInsertSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inExecutorID string, inRunID string, inRunTaskID string, inStop bool, inPhase types.ExecutorTaskPhase, inTimedout bool, inFailError string, inStartTime *time.Time, inEndTime *time.Time, inSetupStep []byte, inSteps []byte) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("executortask").Cols("id", "revision", "creation_time", "update_time", "executor_id", "run_id", "run_task_id", "stop", "phase", "timedout", "fail_error", "start_time", "end_time", "setup_step", "steps").Values(inId, inRevision, inCreationTime, inUpdateTime, inExecutorID, inRunID, inRunTaskID, inStop, inPhase, inTimedout, inFailError, inStartTime, inEndTime, inSetupStep, inSteps)
	}
	executorTaskUpdateSqlite3 = func(curRevision uint64, inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inExecutorID string, inRunID string, inRunTaskID string, inStop bool, inPhase types.ExecutorTaskPhase, inTimedout bool, inFailError string, inStartTime *time.Time, inEndTime *time.Time, inSetupStep []byte, inSteps []byte) *sq.UpdateBuilder {
		ub:= sq.NewUpdateBuilder()
		return ub.Update("executortask").Set(ub.Assign("id", inId), ub.Assign("revision", inRevision), ub.Assign("creation_time", inCreationTime), ub.Assign("update_time", inUpdateTime), ub.Assign("executor_id", inExecutorID), ub.Assign("run_id", inRunID), ub.Assign("run_task_id", inRunTaskID), ub.Assign("stop", inStop), ub.Assign("phase", inPhase), ub.Assign("timedout", inTimedout), ub.Assign("fail_error", inFailError), ub.Assign("start_time", inStartTime), ub.Assign("end_time", inEndTime), ub.Assign("setup_step", inSetupStep), ub.Assign("steps", inSteps)).Where(ub.E("id", inId), ub.E("revision", curRevision))
	}

	executorTaskInsertRawSqlite3 = func(inId string, inRevision uint64, inCreationTime time.Time, inUpdateTime time.Time, inExecutorID string, inRunID string, inRunTaskID string, inStop bool, inPhase types.ExecutorTaskPhase, inTimedout bool, inFailError string, inStartTime *time.Time, inEndTime *time.Time, inSetupStep []byte, inSteps []byte) *sq.InsertBuilder {
		ib:= sq.NewInsertBuilder()
		return ib.InsertInto("executortask").Cols("id", "revision", "creation_time", "update_time", "executor_id", "run_id", "run_task_id", "stop", "phase", "timedout", "fail_error", "start_time", "end_time", "setup_step", "steps").SQL("").Values(inId, inRevision, inCreationTime, inUpdateTime, inExecutorID, inRunID, inRunTaskID, inStop, inPhase, inTimedout, inFailError, inStartTime, inEndTime, inSetupStep, inSteps)
	}
)

func (d *DB) insertExecutorTaskSqlite3(tx *sql.Tx, executortask *types.ExecutorTask) error {
	inSetupStepJSON, err := json.Marshal(executortask.SetupStep)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executortask.SetupStep")
	}
	inStepsJSON, err := json.Marshal(executortask.Steps)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executortask.Steps")
	}
	q := executorTaskInsertSqlite3(executortask.ID, executortask.Revision, executortask.CreationTime, executortask.UpdateTime, executortask.ExecutorID, executortask.RunID, executortask.RunTaskID, executortask.Stop, executortask.Phase, executortask.Timedout, executortask.FailError, executortask.StartTime, executortask.EndTime, inSetupStepJSON, inStepsJSON)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert executorTask")
	}

	return nil
}

func (d *DB) updateExecutorTaskSqlite3(tx *sql.Tx, curRevision uint64, executortask *types.ExecutorTask) (stdsql.Result, error) {
	inSetupStepJSON, err := json.Marshal(executortask.SetupStep)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal executortask.SetupStep")
	}
	inStepsJSON, err := json.Marshal(executortask.Steps)
	if err != nil {
		return nil, errors.Wrap(err, "failed to marshal executortask.Steps")
	}
	q := executorTaskUpdateSqlite3(curRevision, executortask.ID, executortask.Revision, executortask.CreationTime, executortask.UpdateTime, executortask.ExecutorID, executortask.RunID, executortask.RunTaskID, executortask.Stop, executortask.Phase, executortask.Timedout, executortask.FailError, executortask.StartTime, executortask.EndTime, inSetupStepJSON, inStepsJSON)

	res, err := d.exec(tx, q)
	if err != nil {
		return nil, errors.Wrap(err, "failed to update executorTask")
	}

	return res, nil
}

func (d *DB) insertRawExecutorTaskSqlite3(tx *sql.Tx, executortask *types.ExecutorTask) error {
	inSetupStepJSON, err := json.Marshal(executortask.SetupStep)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executortask.SetupStep")
	}
	inStepsJSON, err := json.Marshal(executortask.Steps)
	if err != nil {
		return errors.Wrap(err, "failed to marshal executortask.Steps")
	}
	q := executorTaskInsertRawSqlite3(executortask.ID, executortask.Revision, executortask.CreationTime, executortask.UpdateTime, executortask.ExecutorID, executortask.RunID, executortask.RunTaskID, executortask.Stop, executortask.Phase, executortask.Timedout, executortask.FailError, executortask.StartTime, executortask.EndTime, inSetupStepJSON, inStepsJSON)

	if _, err := d.exec(tx, q); err != nil {
		return errors.Wrap(err, "failed to insert executorTask")
	}

	return nil
}
